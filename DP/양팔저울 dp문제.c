/*---------------
https://www.acmicpc.net/problem/1653 백준 문제 링크.


일단 완전탐색은 불가능함.
input 사이즈가 너무 크다. -> 추가 30개, 추의 무게는 500g이하 종류별로 더하고 빼고, 만들 수 있는 모든 경우의 무게를 완전탐색으로 구하려면 O(30!) 아닐까?

어떻게 해서든 정보를 누적시켜가며, 추들로 표현할 수 있는 state들을 구해나가야 한다는 소리임

추의 무게는 500g이고 30개이하 ---> 최대 표현 가능 무게 15000 이거 제한 걸어줘야함.  ---> 들어오는 물건은 40000g이니까 15000초과는 절대 표현 못하지 쓰레기 input임
(dp사이즈를 표현 가능 범위에 딱 맞게 짰는데, input으로 이거보다 큰거 들어오면 런타임 에러 뜨거든)


자 그럼 dp의 아이디어 메모리 * 내가 봐야할 state의 수
메모리는 추의 개수가 되겠지
내가 봐야할 state의 수는 무게 표현 범위인 15000까지 일테고

생각한 방법은
추를 1개만 사용했을때 state들 갱신 ---> 그냥 dp[현재 사용 추 개수][현재 무게] = 1 이렇게 갱신 되겠지

추를 2개쓰면? ---> state가 두개 갱신될꺼임. dp[1개만 썼을때] 불켜진 state 그대로 내려오고 -> 현재 내 추만 사용, 얹어서 사용 2가지 state 추가
이런식으로 표현 state들을 계속 쌓아가는거임.

근데 문제가 뭐냐???
추를 한쪽에만 올리겠다는 소리임 지금. ---> 추는 반대편에도 올릴 수 있는데 (큰 무게에서 작은 무게를 뺀 무게도 표현 가능하다.)

1 2 5 의 추를 사용한다 치면
1 , 3, 4, 5 이렇게까지 표현이 가능해짐.

-> 그래서 dp쌓아올리는 순서를 반대로 뒤집음. --> (이러면 state들 갱신할때 이전 state에서 추를 빼거나, 더하거나, 내 추만 사용하거나, 내 추를 사용 안하거나) 다 갱신 가능하지
(input이 추의 무게 순서대로 들어와서 sort할 필요도 없었음.)


이렇게 풀었는데 또 문제가 생김!
맨 처음 올려봤던 추에 대해서는 뺀 경우가 없다... ---> 맨 처음 state 갱신할때는 그냥 걔만 띡 갱신하니까... 뺀 경우가 없다..

input:
3
7 8 9
1
6
output : Y

-9 + 8 + 7 을 해야 6을 만들 수 있는데
내 메커니즘에는 이걸 하지 않지. 맨처음 봤던 제일 무거운 추는 뺀 경우가 없음.

그래서 모든 상태가 갱신된 마지막 state 라인에서 맨 처음 넣었던 추를 뺀 state들을 다시 갱신시켰다. ---> 그럼 모든 경우가 그 한줄에 다 들어있게 되는거지
----------------*/

#include <stdio.h>
#include <stdbool.h>

bool dp[31][15001];
int arr[31];
int n;

void fill_dp();

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&arr[i]);

    fill_dp();
    /*for(int i=1;i<=n;i++) // 이건 디버깅용 dp가 어떻게 갱신되는지 확인하기 위한 코드
    {
        for(int j=1;j<22;j++) // 여기서 무게 어디까지 볼지는 알아서 설정해야함. 15000 다 출력하면 화면안에 안들어오지
            printf("%d ",dp[i][j]);
        printf("\n");
    }*/
    int t;
    scanf("%d",&t);
    for(int i=0;i<t;i++)
    {
        int buf;
        scanf("%d",&buf);
        bool flag = true;
        if(buf>15000) // 이 과정이 되게 중요했음. 절대 표현 불가능한 input도 들어오니까 막아줘야함. index 크기 초과해서 에러뜨게 만드는 쓰레기 input임
        {
            printf("N ");
            continue;
        }
        for(int i=0;i<31;i++) // 이걸 for문 돌려서 추의 개수에 따라 state 켜져있는지 훑는 코드로 만들었는데 지금 보니까 필요없는 과정임. buf[1][buf] 만 보면되는데
        {
            if(dp[i][buf])
            {
                printf("Y ");
                flag = false; // 마지막 라인 buf값으로만 딱 참조해서 보면 flag 변수도 필요없어지지
                break;
            }
        }
        if(flag)
            printf("N ");
    }
    return 0;
}

void fill_dp()
{
    dp[n][arr[n]] = true;
    for(int i=n-1;i>0;i--)
    {
        dp[i][arr[i]] = true;
        for(int j=15000;j>0;j--)
        {
            if(dp[i+1][j]==0)
                continue;
            else // 사용가능한 추가 하나 늘때마다 state갱신 가능한 상황이 4개임, ---> 현재 추만 사용하는 경우는 위에, 나머지 3가지는 여기 else문에
            {
                dp[i][j] = true;
                dp[i][j+arr[i]] = true;
                if(j-arr[i]>=0)
                    dp[i][j-arr[i]] = true;
            }
        }
    }
    for(int i=15000;i>0;i--) // 이게 이제 맨처음 state 갱신한 추라서 빼본적이 없기 때문에 따로 처리해준 부분
    {
        if(dp[1][i] == 0)
            continue;
        if(i-arr[n]>=0)
            dp[1][i-arr[n]]= true;
    }
    return;
}
